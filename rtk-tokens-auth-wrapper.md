<!-- Here are some ideas for how to start your blog post about handling authentication and refresh tokens using Redux Toolkit with Next.js using a wrapper layout strategy:

Introduction:
Briefly explain what authentication and refresh tokens are and why they are important.
Mention the benefits of using Redux Toolkit and Next.js to manage authentication.
Introduce the wrapper layout strategy and explain how it can be used to simplify authentication handling in Next.js applications.
Implementation:
Provide a step-by-step guide on how to implement authentication and refresh tokens using Redux Toolkit and Next.js using the wrapper layout strategy.
Include code examples and screenshots to illustrate your points.
Benefits:
Discuss the benefits of using this approach to authentication management.
Highlight how it can help to improve the security and usability of your Next.js application.
Conclusion:
Summarize the key points of your blog post.
Provide links to additional resources for readers who want to learn more about authentication and refresh tokens, Redux Toolkit, and Next.js.
Here is an example of how you could start your introduction:

Authentication and refresh tokens are essential for securing web applications. By using Redux Toolkit and Next.js, you can easily implement a robust authentication system that is both secure and user-friendly. This blog post will show you how to do this using a wrapper layout strategy.

You could then go on to explain the benefits of using Redux Toolkit and Next.js to manage authentication, and introduce the wrapper layout strategy.

In the implementation section, you could provide a step-by-step guide on how to implement authentication and refresh tokens using Redux Toolkit and Next.js using the wrapper layout strategy. Here are some of the key steps you would need to cover:

Install the necessary dependencies.
Create a Redux store and reducers to manage the authentication state.
Create a custom Next.js layout component that wraps all of your application's pages.
Use the wrapper layout component to check the authentication status of the user and redirect them to the login page if they are not authenticated.
Implement a refresh token mechanism to ensure that the user's access token is always valid.
You could include code examples and screenshots to illustrate your points.

In the benefits section, you could discuss the benefits of using this approach to authentication management. Here are some of the key benefits:

Security: The wrapper layout strategy ensures that all pages of your application are protected by authentication. This helps to prevent unauthorized users from accessing your application's resources.
Usability: The refresh token mechanism ensures that users are not logged out unexpectedly if their access token expires. This improves the user experience by making it easier for users to stay logged in to your application.
Simplicity: This approach to authentication management is relatively simple to implement, even for developers who are new to Redux Toolkit and Next.js.
In the conclusion, you could summarize the key points of your blog post and provide links to additional resources for readers who want to learn more about authentication and refresh tokens, Redux Toolkit, and Next.js.

I hope these ideas help you to get started with writing your blog post. -->

Authentication and refresh tokens are essential for securing web applications. However, properly handling sessions and expirations can become a challenge. It's not always clear how to implement these features in a way that is both secure and user-friendly.

In this blog post I'll show you how to leverage from the phantastic Redux Toolkit Query library and web storage (cookies) to implement a robust authentication system that allows users to stay logged in for as long (almost) as they want without having to worry about expiring tokens or session timeouts.

## Introduction

### What are authentication and refresh tokens?

Authentication tokens are used to verify that a user is who they say they are. They are typically generated by the server when a user logs in and are stored in the browser's local storage or session storage.

Usually authentication tokens are short-lived and expire after a certain amount of time. This is done for security reasons, so that if someone steals your token they can't use it forever. However, this can be inconvenient for users who want to stay logged in for longer periods of time. To solve this problem, refresh tokens are used. However, in this blog post we will focus on authentication tokens.

I like storing tokens in the cookies because they have expiration dates, security flags such as `httpOnly`, `SameSite` and `Secure` which make them less accessible to malicious actors whereas local storage is accessible to any script running on the page. [Here] (https://blog.bitsrc.io/why-using-tokens-and-cookies-together-is-better-for-web-apps-9d205b7c1961) is a great article explaining why cookies are better than local storage for storing tokens.

### Using a wrapper layour strategy to persist authentication state

The wrapper layout strategy is a common approach to managing authentication state in Next.js applications. It involves creating a custom layout component that wraps all of your application's pages. This component checks the authentication status of the user and redirects them to the login page if they are not authenticated.

<!-- Here add diagram -->

This approach has several benefits:

- Simplicity: This approach to authentication management is relatively simple to implement, even for developers who are new to Redux Toolkit and Next.js.
- Security: The wrapper layout strategy ensures that all pages of your application are protected by authentication. This helps to prevent unauthorized users from accessing your application's resources.
- Usability: The refresh token mechanism ensures that users are not logged out unexpectedly if their access token expires. This improves the user experience by making it easier for users to stay logged in to your application.

## Implementation

### High level overview

Enough theory, let's get our hands dirty. I expect you to have a basic understanding of Next.js, Redux Toolkit and Redux Toolkit Query and Next.js. You don't really need to have an API with authentication endpoints since we will mock the request and will focus on handling the tokens and the authentication state.

The higher level look of the application is as follows:

<!-- insert higher level diagram -->

### Setting up RTKQ

Considering that we have an existing Next.js with a Redux Toolkit store we will have the auth slice where we're going to set the authentication state and the user slice where we're going to store the user data.

```ts
// store/auth.ts

// this is how the API response could look like
type LoginResponse = {
  token: string;
  refreshToken: string;
  userEmail: string;
  userName: string;
  id: string;
};

const initialState: Partial<LoginResponse> = {};

const slice = createSlice({
  name: 'auth',
  initialState,
  reducers: {},
});

export const authReducer = slice.reducer;
```

Now lets setup the api slice. We will use the `createApi` function from RTKQ to create the api slice. We will have a mutation for the login endpoint and a query for the user endpoint which will be used to get the user data when the user comes back to the application and his token is still valid.

```ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const authApi = createApi({
  reducerPath: 'authApi',
  baseQuery: fetchBaseQuery({
    baseUrl:
      typeof window === 'undefined'
        ? 'http://localhost:3000'
        : window.location.origin,
  }),
  endpoints: (builder) => ({
    login: builder.mutation<
      LoginResponse,
      { userName: string; password: string }
    >({
      query: ({ userName, password }) => ({
        url: '/api/login',
        method: 'POST',
        body: {
          userName,
          password,
        },
      }),
    }),
    getAuthData: builder.query<LoginResponse, { token: string }>({
      query: ({ token }) => ({
        url: 'api/auth-details',
        // if we don't specify the method it will default to GET
        headers: {
          Authorization: `Bearer ${token}`,
        },
      }),
    }),
  }),
});

export const { useLoginMutation } = authApi;
```

Now we need to add the api matchers to the auth slice so that we can update the state when the login or getAuthData endpoints are called. We'll also declare a `setAuthCookie` method that will store the token in the cookies.

```ts
const setAuthCookie = (token: string, name: string) => {
  const toBase64 = Buffer.from(token).toString('base64');

  setCookie(name, toBase64, {
    maxAge: 30 * 24 * 60 * 60,
    path: '/',
    // more security options here
    // sameSite: 'strict',
    // httpOnly: true,
    // secure: process.env.NODE_ENV === 'production',
  });
};

const slice = createSlice({
  name: 'auth',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addMatcher(
        authApi.endpoints.login.matchFulfilled,
        (_state, { payload }) => {
          // set the token in the cookies
          setAuthCookie(payload.token, 'auth_token');

          return payload;
        }
      )
      .addMatcher(
        authApi.endpoints.getAuthData.matchFulfilled,
        (_state, { payload }) => {
          setAuthCookie(payload.token, 'auth_token');
          return payload;
        }
      );
  },
});
```

Finally, it's time to create the wrapper layout component. This component will be used to wrap all of our application's authenticated pages. It will check the authentication status of the user, if it finds a valid token and no auth details in the store it will call the `getAuthData` endpoint to get the user data and update the store. If it doesn't find a valid token it will redirect the user to the login page.

```tsx
import { useRouter } from 'next/router';
import { useDispatch, useSelector } from 'react-redux';

type Props = {
  children?: React.ReactNode;
};

export const AuthWrapper = ({ children }: Props) => {
  const dispatch = useDispatch();
  const { push } = useRouter();
  const { userEmail } = useSelector((state: RootState) => state.auth);

  const { token } = getValidAuthTokens();

  // this query will only execute if the token is valid and the user email is not already in the redux store
  const { error, isLoading } = useGetAuthDataQuery(
    { token: token || '' },
    {
      // The useGetAuthDataQuery hook will not execute the query at all if these values are falsy
      skip: !!userEmail || !token,
    }
  );

  // if the user doesnt have a valid token, redirect to login page
  useEffect(() => {
    if (!token) {
      push('/login');
    }
  }, [token, push]);

  return children;
};
```

We can wrap all the routes that should be authenticated using the `Page.getLayout` feature from Next.js. This will allow us to wrap all the pages that should be authenticated with the `AuthWrapper` component.

```tsx
Page.getLayout = function getLayout(page) {
  return <AuthWrapper>{page}</AuthWrapper>;
};
```

This should be enable in `_app.tsx` so that it applies to all the pages. More info about per page `getLayout` [here](https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts#per-page-layouts).

```tsx
// pages/_app.tsx
export default function MyApp({ Component, pageProps }) {
  // Use the layout defined at the page level, if available
  const getLayout = Component.getLayout || ((page) => page);

  return getLayout(<Component {...pageProps} />);
}
```

You can also individually wrap every protected page with the `AuthWrapper` component. This approach is also valid, however I don't find it as clean as the previous one.

```tsx
// pages/protected-page.tsx
const ProtectedPage = () => {
  return (
    <AuthWrapper>
      {
        // page content
      }
    </AuthWrapper>
  );
};
```
